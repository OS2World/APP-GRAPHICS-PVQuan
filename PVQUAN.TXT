
                         PVQUANT Version 1.60

                     Colour Quantisation Utilities

                              for the

                    Persistence of Vision Raytracer
















Written and Distributed by:  

Frank van der Hulst, 101 Epuni St, Lower Hutt, New Zealand 

Electronic mail to:  
UseNet:  f_vander@comp.vuw.ac.nz, 
         frank@cit.ac.nz,
         frank@whare.cavebbs.welly.gen.nz 
FidoNet: frank vanderhulst at GenBoard (Node 3:771/160)

01 December 1992
컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴 

These programs are freely distributable.  The authors retain the copyright 
to the program but authorizes free distribution by BBS'es, networks, 
magnetic media, etc.  The distributor may charge no more than five dollars 
($5) U.S.  for this software.  

The images and data files generated by these programs are the property of 
the user of the software and may be used for any purpose without 
restriction.  

The authors make no guarantees or warranties with these programs and claim 
no responsibility for any damage or loss of time caused by this program.  
Bug reports may be sent to the authors but the authors are under no 
obligation to provide bug fixes, features, or any support for this software.  

The following conditions are placed on the use of this program:  

1) That it should not be used as part of any commercial package without the 
explicit written consent of the author.  

2) If you make any changes to the source code, please let me know.  That's 
the way this program was built!  

3) This text file must accompany the program.  

This manual is divided into the following sections:  

1) Archive Description 
2) Getting Started
3) Command Line Parameters
4) Output File Format
5) Source Code Information
6) Displaying the Images
7) Animation
8) Porting to Different Platforms
2) Background

1) Archive Description 
~~~~~~~~~~~~~~~~~~~~~~ 
This archive contains C source code for a set of programs to convert image
files produced by DKB-Trace or Persistence of Vision raytracer into a format
suitable for display on a VGA screen, or to GIF format.  It includes
programs to generate a single stereoscopic 3D image from two views of a
scene, as well as programs to produce animation from multiple ray-traced
images.  

The programs (or large parts of them) were written by several different 
people.  All of the programs are in the public domain to some extent, with 
some restrictions put on them by their respective authors.  I have collected 
these from various places, ported them to Turbo-C, GNU C, or IBM C Set/2 if 
necessary, and formatted them in a way that I like.  The copyright for each 
program still belongs to its author -- my copyright claim extends only to 
the collection of programs (like the editor of a journal, for example).  

QUANT (HECKBERT & OCTREE):  Colour quantisation program which post-processes 
raw or Targa image files produced by the Persistence of Vision Ray Tracer
(PoVRay). Two versions can be compiled:  one uses Heckbert's
median-splitting algorithm, whereas the other uses Octree quantisation.

DISPLAY:  Displays either 320x400 or 320x200 images, either 2D, or stereo 
3D.  3D images require Sega 3D-glasses to be connected to the serial port 
for viewing.  

ANIMDAT:  Reads an animation source file (*.VAR), and uses it to generate
data files for the PoV ray tracer.  

ANIMGIF:  Produces a .GIF file containing a series of images to be displayed 
by ANIM.  

ANIMFLI:  Produces a .FLI file containing a series of images to be displayed 
by a .FLI player (e.g.  Autodesk's AAPLAY).  



2) Getting Started
~~~~~~~~~~~~~~~~~~ 
Before quantising an image, you must create one!  Use either DKB-TRACE or
PoVRAY to produce output in the "Targa" format.

I use the following command line:  

POVRAY -ipacman.dat -opacman.tga -w320 -h400 -v +ft +p +x -a

See the raytracer documentation on what all the above mean.  Most important 
is the "+ft" option which tells the raytracer to produce "Targa" files.  The 
quantiser can also read "raw" format files (use the "+fr" switch).  If you 
use this (there's no real reason why you should) and run POVRAY on a PC,
you'll probably need to rename the files produced.  By default it gives 
extensions of .R8, .G8, and .B8, whereas QUANT needs extensions of .RED, 
.GRN, and .BLU.  

Now try running the OCTREE quantiser program:  

OCTREE pacman 

3) Command Line Parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~ 
QUANT is a program to convert image files produced by DKB-Trace or
Persistence of Vision raytracer into a format suitable for display on a VGA
screen.  

To do this, it must select 256 colours from a palette of 256K colours to 
best represent the colours in the image file which are selected from a 
palette of 16 million.  In other words, it must "quantise" the colours in 
the image file (which are selected from a palette of 16 million) into a set 
of 256 colours selected from a palette of 256K colours.  

QUANT is a colour quantisation program which post-processes raw or 
Targa image files produced by the Persistence of Vision Ray Tracer (PoV 
Ray). Two versions can be compiled:  one uses Heckbert's median-splitting
algorithm, whereas the other uses Octree quantisation.  The Heckbert version
takes much longer to run, especially on a 286.  On the other hand, it
produces much better results.  The Octree version is faster, but not as
good.  

As an additional feature, the program allows the user to generate a single 
palette from several image files, thus making it possible to produce a 
stereoscopic 3D image from two views of a scene, or animation.  

Command line format:  

HECKBERT [-C=colours][-W=width][-H=height][-D=display][-T=type] 
         [-O=outputbits][-S=speed][-N=numfiles] file_name

or 

OCTREE [-C=colours][-W=width][-H=height][-D=display][-T=type] 
       [-O=outputbits][-N=numfiles] file_name

If no parameters are given, a usage message is shown.  

                                                            Default value
outputbits = bits per colour being output                   [6]
intype = 0 or 1 to select input format                      [0]
            0 selects raw files (.RED, .GRN,.BLU)
            1 selects Targa (.TGA)
type = 0, 1 or 2 to select output format                    [1]
            0 selects 4-planar  output for 320x400 or 320x200 images
            1 selects linear output
            2 selects GIF output.
display = 1 to display while outputting                     [1]
            Only available on the PC.
colours = number of separate colours to produce             [256]
width = number of pixels wide the image is                  [320]
height = number of pixels high the image is                 [200]
speed = 1 or 0 for fast or slow quantisation                [0]
            Heckbert speed switch.  If zero, the program does another pass
            through the data, to find the optimal palette selection.  This
            pass is much slower than the earlier passes, and produces
            slightly better results.
numfiles = number of files to convert                       [1]
            If  numfiles = 1, QUANT calculates a palette for that file and
            writes it to disk with a .2D extension.  
            If numfiles = 2, QUANT calculates one combined palette from both
            images, then writes this palette, as well as the data from
            both files to an output file with a .3D extension.  
            If numfiles > 2, QUANT assumes this is an animation sequence, 
            and generates one palette for all the files, then writes the
            output in the form of several 2D-format files (one for each 
            input file), all with the same palette.  The files are named
            FILE_0.0, FILE_0.1, FILE_0.2, ...

file_name   the base part of the filename(s) of files to be converted -- a
            numeric part and an extension are added automatically.  The
            numeric part consists of an underscore followed by a number, and
            the extension will depend on the input file type.  (e.g.  if the
            file_name is PAC and the input type is Targa, the first file 
            read will be PAC_0.TGA.

When the final result is to be a .FLI file, it may be better to generate the 
palette for each image separately, since .FLI players can use different 
palettes for each frame.  

For example, 

C:\>OCTREE GLASS -c=16 

will open the files GLASS.RED, GLASS.GRN, and GLASS.BLU, use Octree 
quantisation to find the 16 best colours, then write the output to to the 
file GLASS.2D.  As it creates the file, it will display the image on the 
screen.  

C:\>HECKBERT PACMAN -n=2 -c=64 -d=0 

will open the files PACMAN_0.RED, PACMAN_0.GRN, and PACMAN_0.BLU, then the 
files PACMAN_1.RED, PACMAN_1.GRN, and PACMAN_1.BLU, then create the file 
PACMAN.3D.  This will be done using Heckbert's median-splitting algorithm.  

C:\>HECKBERT PACMAN -i=1 -t=1 

will open the file PACMAN.TGA, and create the file PACMAN.2D.  This will be 
done using Heckbert's median-splitting algorithm.  

C:\>HECKBERT TEST -n=4 

will read the files TEST_0.RED/GRN/BLU, TEST_1.RED/GRN/BLU, etc., then 
create the files TEST_0.0, TEST_0.1, TEST_0.2, and TEST_0.3.  This will be 
done using Heckbert's median-splitting algorithm.  

Note that both versions of QUANT require large amounts of memory.  


4) Output File Format
~~~~~~~~~~~~~~~~~~~~~ 
QUANT produces output in one of four possible output formats:  

GIF 
2D -- a single image 
3D -- two stereoscopic images of the same scene 
nn -- animation 

The GIF output file can be displayed using a GIF display program such as 
CSHOW or Image Alchemy.  The 2D and 3D format files can be displayed using 
the provided DISPLAY program.  The animation output is in the form of 
several 2D-format files (one for each input file), all with the same 
palette.  The files are named FILE_1.1, FILE_1.2, FILE_1.3, ...  

The 2D and 3D files have the following format:  
7-byte header 
256*3-byte palette 
one or two screen images (one byte per pixel).  

The header consists of:  

<signature> - 2 bytes long, value '2D' or '3D', depending on the image type.  
<num columns> - 2 bytes long (LS byte first) 
<num rows> - 2 bytes long (LS byte first) 
<num colours> - 1 byte 

The palette consists of a series of 3-byte fields, each corresponding to the 
combination of blue, green, and red signals for the corresponding colour.  A 
zero value in the <num colours> field represents 256 colours.  

A screen image can be in one of two formats:  4-planar or linear 
(corresponding to setting the type command line parameter to 0 or 1).  

The  4-planar format was designed to make it fast and easy to display an
image in either 320x400x256 or 320x200x256 mode.  To facilitate this, the
format of screen image(s) is similar to the memory organisation of the VGA
card in that mode.  For any other image size, the program automatically
outputs images in the linear format.  

Each byte is used by the VGA card as an index into the palette, which is 
then used to display the correct colour on the screen.  
 
For the 4-planar format of a 320x400 image, each screen image is made up of 
128,000 bytes, one per pixel.  Because of the memory organisation of the VGA 
card, each image is made up of 4 banks of 32,000 bytes.  A VGA register is 
set, then a bank is loaded into VGA memory.  Each bank consists of 80 bytes 
per scan line by 400 scan lines.  The bytes from the four banks illuminate 
adjacent pixels.  For a 4-planar 320x200 image, the total image size is 
64,000 bytes, made up of 4 banks of 16,000.  

In the linear format, each byte in turn is stored.  

5) Source Code Information
~~~~~~~~~~~~~~~~~~~~~~~~~~ 
This program is the amalgamation of several pieces of work by different
authors:  

The colour quantisation algorithms used in QUANT come from two sources:  

1.  The files OCTREE.C and OCTREE.H are based on code written by Wolfgang
Stuerzlinger who placed it in the public domain.  The code implements the 
algorithm described in:

Graphic Gems, edited by Andrew Glassner 
Article:  A Simple Method for Color Quantisation: Octree Quantisation, 
pg. 287 ff by:  Michael Gervautz, Werner Purgathofer
 Technical University, Vienna, Austria

2. The files HECKBERT.C and HECKBERT.H are based on COLORQUANT.C written by 
Craig E Kolb who placed it in the public domain.  

The GIF output code is based on code in version 1.1 (Sep.  1990) of Gif-Lib, 
a package written by Gershon Elber.  

The FLI creation code comes from FLI.LIB (Dec 1989) by Jim Kent of Dancing 
Flame, San Francisco.  Following is an excerpt from his README file:  

Fli.lib and the associated source and documentation files are Copyright 1990 
Dancing Flame, San Francisco.  Permission is granted to distribute fli.lib 
and to use fli.lib in any non-commercial program.  If you would like to use 
fli.lib in a commercial program please contact Dancing Flame.  The normal 
licensing fee is the retail price of 5 copies of the program you are 
selling.  

Dancing Flame 
3312 16th St.  
San Francisco, CA 94114.  
(415) 861-6119

The VGA 320*400 output is based on a program published by Michael Abrash in 
Programmer's Journal.  

The VGA 320*200 output is based on a program (FLIPDEMO.ASM) sent to me by K. 
Heidenstrom.  

ANIMDAT was written by Todd Sankey (sankey@unixg.ubc.ca), who sent me the 
source code for it. This is largely unchanged from his version, except that
I replaced *.DAT with *.POV.

All of the above programs are in the public domain.  

I took all these bits and chopped them round a bit to make them work the way 
I like, and added my own code to do things like outputting to my 2D/3D file, 
virtual memory management, handle command line parameters, etc.  


6) Displaying the Images
~~~~~~~~~~~~~~~~~~~~~~~~ 
The DISPLAY program provided will display either 320x400 or 320x200 images,
either 2D, or stereo 3D.  According to Abrash's article, this should work on
any VGA or SVGA card.  (On one machine which has a VGA card, this didn't
work).  It has the following command line options:  

Command line format:  

DISPLAY FILE1 [FILE2]...  [/W] [/C] [/R] [/H]

where FILE1, FILE2...  are the names (with extensions) of files to be 
displayed.  

/W => wait after each following image has been displayed 
/C => clear screen after each image 
/R => reverse eye-image sync for following 3D images 
/H => toggle screen height between 400 and 200 line modes

Each of these switches acts as a toggle.  The program has the following 
defaults:  wait after each image for a keypress before displaying the next 
clear the screen after each image first image of a 3D-pair is for left eye, 
second is for right eye 400 line mode 

7) Animation
~~~~~~~~~~~~ 
Two programs are provided to support animation:
1) ANIMDAT generates .POV files for PoVRay
2) ANIMFLI converts multiple 2D files into a FLI file

ANIMDAT: This program reads an animation source file (*.VAR) and a template
.POV file, and uses them to generate multiple data files for the PoV ray 
tracer.

Command format:

ANIMDAT filename

For more information, read ANIMDAT.DOC, found in the ANIMDAT.ZIP archive.

ANIMFLI:  This program produces a .FLI file containing a series of images to 
be displayed.  The images to be read in must be generated by QUANT (either 
version) with the output format set to "type 1" (single plane) Image size 
must be 320x200.  

This file can then be read by any standard FLI player to produce animation.  

Command line format:  ANIMFLI INPUT_FILE OUTPUT_FILE 

where INPUT_FILE is the name (without any extension) of the sequence of 
input files to be loaded into the FLI 

OUTPUT_FILE is the name (without extension) of the FLI file to be created.  


8) Porting to Different Platforms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
I've tried to make QUANT portable.  So far, it's working out fairly
well. All the programs (except DISPLAY -- it is specific to MS-DOS)
compile cleanly and run properly (no warnings, no errors) using either
Turbo-C++ v1.00, GNU C, or IBM C Set/2.

If you want to port QUANT to another system, please try to modify the core 
as little as possible.  

Similarly, if you implement a different quantisation algorithm, try to keep 
it as a separate module.


9) Background
~~~~~~~~~~~~~ 
I used to have a 286 PC clone with a VGA screen, and am interested in 
virtual reality.  I knew that a 286 doesn't have the horsepower to be
good for that, but that's all I had.  Attached to this I had a pair of
Sega 3D glasses, which allowed me to view see a 3D image by displaying
stereoscopic pairs of images on the screen.

I started off drawing images with Turbo C, but that was time-consuming and 
not very effective.  I then got a copy of DBW_RENDER and used it (over many 
nights over many weeks) to produce images.  In the meantime, Craig Kolb had 
sent me a copy of his COLORQUANT code, which I ported to Turbo C. I also 
found code to display images in 320x400 mode on my VGA.  Finally I could 
display some good images.  I modified the quantiser to read two input files 
to produce one palette, so that I could display a 3D image.  

The primitives available in DBW_RENDER were very limited, so I switched to 
DKB-TRACE v2.12.  And ran my machine day and night for months.  

Then I got access to a 486 running SCO Unix.  Great!  My 286 took a rest at 
nights, because I could generate the most complex scenes in only a few 
hours.  Unfortunately, I couldn't display the images, or even move them 
easily from the 486 (the only direct interchange medium is 360K floppies, 
and the QRT-format files are too big).  Also working with the QRT-format was 
clumsy, so I converted the quantiser to read raw format files (each of which 
is only 128K long, thus easily transported).  Then I saw a copy of the 
Octree quantisation code on UseNet, so I tried that.  It was much faster (a 
real advantage on the PC) but produced inferior results.  Next step was to 
move the quantiser to Unix, and suddenly the Heckbert technique was best.  

The extra speed of the Unix box opened up some new possibilities -- I 
started to look at animation.  I could generate about seven images per hour, 
then use a display program to flip them up one by one.  That works fine 
(although it needs a lot of memory on the PC).  

Then I received an assembler source file by K. Heidenstrom which did page 
flipping in 320*200*256 mode.  This makes animation easier, since each image 
requires less memory.  It also makes 3D animation possible.  

Then I got access to a Sun IPC workstation than the the '486 -- so I've
ported the raytracer and other files to compile using the GNU C compiler
gcc.  

The GIF display program needs lots of memory, and the files (even after GIF 
compression) are huge...  the GIF standard isn't well suited to animation.  
So I took the FLILIB source from Simtel...  that was designed to be compiled 
on the PC using TurboC (included was 8086 assembler source code to open and 
close files, amongst other things).  I ported that to gcc, converting things 
back to C and fixing some annoying pointer addressing problems.  

Now I have a '486 on my desk, running OS/2. So I've ported the POV ray 
tracer source code to the IBM C Set/2 compiler, and also the various 
utilities. Todd Sankey also provided a neat animation file generator, which 
fitted in very well with what I was after.

Next is Floyd-Steinberg dithering, to remove unwanted "banding" of coloured 
regions (called false contours).  

Or maybe adding sound to a FLI player.  Or perhaps 3d animation....  


